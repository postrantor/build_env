# env
if [ -n "$BASH_VERSION" ]; then
    source /opt/ros/*/setup.bash
    source ${QUAD_WORKDIR}/install/setup.bash
elif [ -n "$ZSH_VERSION" ]; then
    source /opt/ros/*/setup.zsh
    source ${QUAD_WORKDIR}/install/setup.zsh
fi

# rmw
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
# export CYCLONEDDS_URI=""

# gazebo
architecture=$(uname -m)
if [[ "$architecture" == "x86_64" ]]; then
    source /usr/share/gazebo/setup.sh
    export GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:/opt/ros/${ROS_DISTRO}/lib
    #export GZ_VERSION=fortress
    # "/usr/lib/x86_64-linux-gnu/gazebo-11/plugins:/opt/ros/${ROS_DISTRO}/opt/rviz_ogre_vendor/lib:/opt/rti.com/rti_connext_dds-6.0.1/lib/x64Linux4gcc7.3.0:/opt/rti.com/rti_connext_dds-6.0.1/bin:/opt/ros/${ROS_DISTRO}/lib/x86_64-linux-gnu:/usr/share/gurumdds/cmake/../../../lib:/opt/ros/${ROS_DISTRO}/lib:/usr/lib/x86_64-linux-gnu/gazebo-11/plugins::/usr/lib/x86_64-linux-gnu/gazebo-11/plugins:/usr/lib/x86_64-linux-gnu/gazebo-11/plugins:"
elif [[ "$architecture" == "aarch64" ]]; then
    echo "Current machine is ARM architecture"
else
    echo "Unknown CPU Architecture: $architecture"
fi

# add colcon
source ${QUAD_WORKDIR}/.env/colcon_cd.sh
source ${QUAD_WORKDIR}/.env/colcon-argcomplete.bash
export _colcon_cd_root=/opt/ros/${ROS_DISTRO}/

# set colcon::build
export COLCON_DEFAULTS_FILE=${QUAD_WORKDIR}/.config/build-args.yaml # for `colcon build`
export COLCON_HOME=${QUAD_WORKDIR}/.config/                         # for colcon.meta

# add vcs-complete
source ${QUAD_WORKDIR}/.env/vcs.bash
export QUAD_REPO=${QUAD_WORKDIR}/.config/quadruped.repos

# go to workspace
function cd_ws() {
    declare -A paths=(
        ["model"]="${QUAD_WORKDIR}"
        ["control"]="${HOME}/project/control_ws"
        ["unitree"]="${HOME}/project/unitree_ws"
    )

    if [[ -z ${paths[$1]} ]]; then
        echo "Invalid argument. Usage: cd workspace [control|demo|unitree] [custom_args]"
        return 1
    fi

    cd "${paths[$1]}"

    if [ -n "$BASH_VERSION" ]; then
        source "./install/setup.bash"
    elif [ -n "$ZSH_VERSION" ]; then
        source "./install/setup.zsh"
    fi
}

# colcon build target workspace
function colcon_ws() {
    cd_ws $1
    shift # drop before args
    colcon build "$@"
}

function colcon_remove() {
    # Usage example:
    # colcon_remove package_1 package_2
    if [ $# -eq 0 ]; then
        echo "Usage: colcon_remove <package_1> <package_2> ... <package_N>"
        return 1
    fi

    for package in "$@"; do
        install_dir="install/$package"
        build_dir="build/$package"

        if [ -d "$install_dir" ]; then
            echo "Removing $install_dir"
            rm -rf "$install_dir"
        else
            echo "$install_dir does not exist."
        fi

        if [ -d "$build_dir" ]; then
            echo "Removing $build_dir"
            rm -rf "$build_dir"
        else
            echo "$build_dir does not exist."
        fi
    done
}

# import quad repo
function import-quad-src() {
  echo "importing quad src..."
  # 创建 src 目录，存在时不报错
  if ! mkdir -p ./src; then
    echo "Error: Failed to create ./src directory." >&2
    return 1
  fi
  # 导入仓库
  if ! vcs import --retry 3 --force -w 5 --input "$QUAD_REPO" ./src; then
    echo "Error: Failed to import repositories using vcs." >&2
    return 1
  fi
  echo "Import completed successfully."
  return 0
}

# install dependencies from packages.xml
function install-dependencies() {
    # sudo rosdep init
    # rosdep update
    rosdep install \
        -y \
        --from-paths "$@" \
        --ignore-src \
        --skip-keys "serial \
                unitree_msgs \
                unitree_sdk \
                quadruped \
                tinynurbs \
                tiny_ekf \
                quadprog \
                matplotlib_cpp \
                qpOASES \
                SuiteSparse \
                message_generation \
                message_runtime \
                catkin \
                xpp_msgs"
}

# ignore target folder
function ignore-directory() {
  local ignore_file="./src/.colcon-ignore-$1"
  local path_pattern="*/$2"

  if [[ ! -e $ignore_file ]]; then
    touch "$ignore_file"
    echo -e "\033[1;31mYou should \`touch ./src/$2/COLCON_IGNORE\`\033[0m"

    for dir in $(find ./ -type d -maxdepth 3 -path "$path_pattern" 2>/dev/null); do
      if [[ -d "$dir" ]]; then
        if ! touch "$dir/COLCON_IGNORE"; then
          echo -e "\033[1;31mWarning: Failed to create COLCON_IGNORE in $dir.\033[0m" >&2
        else
          echo "Created COLCON_IGNORE in $dir"
        fi
      fi
    done
  fi
}

# ignore colcon packages
function ignore-colcon-pkg() {
  declare -A IGNORE_LIST=(
    [control]="ros2-control/ros2-control"
    [controllers]="ros2-control/ros2-controllers"
    [parameter]="ros2-control/generate-parameter-library"
    [infrastructure]="ros2-infrastructure"
    [reference]="reference"
    [interfaces]="interfaces/geometry2"
    [simulation]="simulation"
  )

  # 遍历忽略目录
  for key in "${!IGNORE_LIST[@]}"; do
    ignore-directory "$key" "${IGNORE_LIST[$key]}"
  done
}

# format-target-folder-by-clang-format
# 
# 功能描述：
#   格式化指定文件夹中的 C++ 源文件（`.h`, `.cpp`, `.hpp`），使用指定的 `.clang-format` 配置文件。
#
# 参数：
#   $1: folder - 需要格式化的目标文件夹路径。
#   $2: format_file - `.clang-format` 配置文件的路径。
#
# 使用示例：
#   format-target-folder-by-clang-format "src/quadruped/model-predictive-control/" ".clang-format"
#
# 注意事项：
#   1. 确保 `clang-format` 已安装并可用。
#   2. 确保 `.clang-format` 配置文件存在且格式正确。
#   3. 该函数会递归查找目标文件夹中的所有 `.h`, `.cpp`, `.hpp` 文件，并对其进行格式化。
#
function format-target-folder-by-clang-format() {
  local folder=$1
  local format_file=$2
  local format_command="clang-format -i -style=file:$format_file"
  echo "running: $format_command"
  find "$folder" -type f \( -name "*.h" -o -name "*.cpp" -o -name "*.hpp" \) | xargs -I {} $format_command {}
}

# find-and-format-packages
#
# 功能描述：
#   在指定的搜索路径下查找所有 `package.xml` 文件，检查其内容是否包含指定的 `<name>${package_name}</name>` 标签。
#   如果找到匹配的标签，并且目标文件夹中不存在 `COLCON_IGNORE` 文件，则对该文件夹中的 C++ 源文件进行格式化。
#
# 参数：
#   $@: package_names - 需要查找的包名称列表（可变参数）。
#   search_path: 搜索 `package.xml` 文件的根路径，默认为 `${QUAD_WORKDIR}/src`。
#   format_file: `.clang-format` 配置文件的路径，默认为 `${QUAD_WORKDIR}/.clang-format`。
#
# 使用示例：
#   find-and-format-packages "package1" "package2"
#
# 注意事项：
#   1. 确保 `QUAD_WORKDIR` 环境变量已正确设置。
#   2. 确保 `.clang-format` 配置文件存在且格式正确。
#   3. 如果目标文件夹中存在 `COLCON_IGNORE` 文件，则跳过该文件夹的格式化操作。
#   4. 该函数会递归查找 `search_path` 下的所有 `package.xml` 文件。
#
export clang_format_path="${QUAD_WORKDIR}"/.clang-format
function find-and-format-packages() {
  local package_names=("$@")  # 从参数中获取 package_name 列表
  local search_path="${QUAD_WORKDIR}/src"  # 指定搜索路径
  local format_file=$clang_format_path

  # 查找所有 package.xml 文件
  find "$search_path" -name "package.xml" | while read -r xml_file; do
    for package_name in "${package_names[@]}"; do
      if [[ -n "$xml_file" ]]; then
        if grep -q "<name>${package_name}</name>" "$xml_file"; then
          echo "Found <name>${package_name}</name> in $xml_file"
          # 检查是否存在 COLCON_IGNORE 文件
          local package_dir=$(dirname "$xml_file")
          if [[ -f "$package_dir/COLCON_IGNORE" ]]; then
            echo "Skipping $package_dir due to COLCON_IGNORE"
          else
            format-target-folder-by-clang-format "$package_dir" "$format_file"
          fi
          break
        fi
      else
        echo "No ${package_name}.xml found in $search_path"
      fi
    done
  done
}
